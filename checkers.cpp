#include "checkers.h"


Checkers::Checkers()
{
    init();
}

// Инициализатор (сброс в начальное состояние)
//--------------------------------------------------------------
void Checkers::init()
{
    // Инициализация состояния игры
    move_state = 0;
    move_order = occupied_field | white_checker;
    error_code = false;
    game_ended = false;
    must_bit = 0;

    // Заполнение начальной позиции шашек
    for (int i=0; i<8; i++)     // Двойной цикл по координатам
    {
        for (int k=0; k<8; k++)
        {
            if ((i+k)%2 == 0)   // Клетки с четной суммой координат - белые
            {
                position[i][k] = white_field;
            }
            else if (k<3)       // Три верхних ряда черных клеток - черные шашки
            {
                position[i][k] = occupied_field;
            }
            else if (k>4)       // Три нижних ряда черных клеток - белые шашки
            {
                position[i][k] = occupied_field | white_checker;
            }
            else                // Остальные черные клетки - пустые
            {
                position[i][k] = black_empty_field;
            }
        }
    }
}

// Выдача информации о текущих свойствах клетки
//--------------------------------------------------------------
int Checkers::getType(int i, int k)
{
    // Для координат, выходящих за пределы поля,
    // возвращаем признак "белая клетка" -
    // чтобы не проверять выход за пределы поля отдельно
    if ((i < 0) || (i > 7)) return white_field;
    if ((k < 0) || (k > 7)) return white_field;

    // Для координат на поле возвращаем хранимое значение
    return position[i][k];
}

// Обработка клика по клетке
//--------------------------------------------------------------
void Checkers::click(int i, int k)
{
    if (game_ended) return;     // Если конец игры, ничего не делаем
    error_code = 0;             // Сбрасываем признак ошибки, если был

    // Реакция на клик зависит от текущего состояния хода
    switch (move_state)
    {
    //--------------------------------------------------------------
    case 0: // Если шашка не выбрана
        // Обрабатываем только клетки, занятые шашками цвета хода
        // Для этого на тип клетки накладываем нужную маску
        // и результат сравниваем с признаком очередности хода
        if ((getType(i, k) & checker_mask) == move_order)
        {
            position[i][k] |= selected_field;   // Устанавливаем признак поля
            selectedI = i;          // Запоминаем координаты выбранной шашки
            selectedK = k;
            move_state = 1;         // Изменяем состояние хода
        }
        break;

    //--------------------------------------------------------------
    case 1: // Если шашка выбрана
        // Снова обрабатываем клетки, занятые шашками цвета хода:
        // на тот случай, если игрок захочет изменить выбор
        if ((getType(i, k) & checker_mask) == move_order)
        {
            // Если клик по выбранной клетке,
            // значит нужно сбросить выбор
            if (getType(i, k) & selected_field)
            {
                position[i][k] &= ~selected_field;  // Сбрасываем признак поля
                move_state = 0;     // Изменяем состояние хода
            }
            // иначе заменяем выбранную шашку
            else
            {
                position[selectedI][selectedK] &= ~selected_field; // Сбрасываем
                position[i][k] |= selected_field;   // Устанавливаем признак поля
                selectedI = i;          // Запоминаем координаты выбранной шашки
                selectedK = k;
            }
        }
        // Теперь обрабатываем и пустые клетки
        else if ((getType(i, k) & empty_mask) == 0)
        {
            // Если нужно бить, проверяем правильность удара
            if (must_bit && bit(selectedI, selectedK, i, k))
            {
                selectedI = i;          // При успехе изменяем координаты шашки
                selectedK = k;
                if (canBit(i, k))       // Проверяем, можем ли бить дальше
                {
                    move_state = 2;     // Если можем, устанавливаем новое состояние
                }
                else                    // иначе завершаем ход:
                {
                    deleteBited();                  // удаляем с доски побитые шашки
                    position[i][k] &= ~selected_field;  // сбрасываем признак выбора
                    move_state = 0;                 // устанавливаем начальное состояние
                    move_order ^= white_checker;    // переключаем очередность хода
                    testCurrentPosition();          // производим анализ новой позиции
                }
            }
            // Проверяем нашу пару кдеток на тихий ход
            else if (move(selectedI, selectedK, i, k))  // При успехе
            {
                position[i][k] &= ~selected_field;  // сбрасываем признак выбора
                move_state = 0;                     // устанавливаем начальное состояние
                move_order ^= white_checker;        // переключаем очередность хода
                testCurrentPosition();              // производим анализ новой позиции
            }
            // Если что-то не так, сбрасываем выбор и начнем все с начала
            else
            {
                position[selectedI][selectedK] &= ~selected_field; // сбрасываем признак
                move_state = 0;                     // устанавливаем начальное состояние
            }
        }
        break;

    //--------------------------------------------------------------
    case 2: // Если продолжается ход с боем шашек
        // Обрабатываем только пустые клетки - ход начат,
        // сброс выбора уже не возможен
        if ((getType(i, k) & empty_mask) == 0)
        {
            // Раз сюда попали, значит, гарантированно нужно бить,
            // проверяем правильность удара
            if (bit(selectedI, selectedK, i, k))
            {
                selectedI = i;          // При успехе изменяем координаты шашки
                selectedK = k;

                if (!canBit(i, k))      // Если не можем бить дальше, то завершаем ход:
                {
                    deleteBited();                  // удаляем с доски побитые шашки
                    position[i][k] &= ~selected_field;  // сбрасываем признак выбора
                    move_state = 0;                 // устанавливаем начальное состояние
                    move_order ^= white_checker;    // переключаем очередность хода
                    testCurrentPosition();          // производим анализ новой позиции
                }
            }
        }
    }
}

// Выдача текущего статусного сообщения
//--------------------------------------------------------------
QString Checkers::getMessage()
{
    QString msg;        // Поле для сообщения
    if (game_ended)     // Конец игры обрабатываем отдельно
    {
        if (white_checker & move_order) // В зависимости от очередности хода
        {
            msg = QT_TR_NOOP("Игра окончена. Черные выиграли.");
        }
        else
        {
            msg = QT_TR_NOOP("Игра окончена. Белые выиграли.");
        }
    }
    else    // иначе сообщение формируется из трех частей
    {
        // Сообщение об очередности хода
        if (white_checker & move_order) // В зависимости от очередности хода
        {
            msg = QT_TR_NOOP("Ход белых. ");
        }
        else
        {
            msg = QT_TR_NOOP("Ход черных. ");
        }

        // Сообщение об ошибке, если есть
        switch (error_code)
        {
        case 1:
            msg += QT_TR_NOOP("Так нельзя ходить! ");
            break;
        case 2:
            msg += QT_TR_NOOP("Обязательно нужно бить! ");
            break;
        case 3:
            msg += QT_TR_NOOP("Нужно повернуть! ");
        }

        // Сообщение о продолжении хода, если состояние 2
        if (move_state == 2)
            msg += QT_TR_NOOP("Продолжайте ход.. ");
    }
    return msg;
}

//-------------------------------------------------------------------------------------
//-- Совсем мелкие служебные процедуры
//-- для работы с координатами клеток и направлениями движения шашек
//-------------------------------------------------------------------------------------

// Вычисление горизонтальной координаты следующей клетки
// в заданном направлении движения шашки
//--------------------------------------------------------------
int Checkers::nextI(int i, int d)
{
    return (d & 1) ? i+1 : i-1;     // нулевой бит направления
}

// Вычисление вертикальной координаты следующей клетки
// в заданном направлении движения шашки
//--------------------------------------------------------------
int Checkers::nextK(int k, int d)
{
    return (d & 2) ? k+1 : k-1;     // первый бит направления
}

// Вычисление числового значения направлении движения шашки
// по координатам начальной и конечной клетки
//--------------------------------------------------------------
int Checkers::direction(int i1, int k1, int i2, int k2)
{
    int d = 0;
    if (i2 > i1) d |= 1;     // нулевой бит направления
    if (k2 > k1) d |= 2;     // первый бит направления
    return d;
}

// Проверка принципиальной допустимости движения шашки
// по координатам начальной и конечной клетки
// (нахождение клеток на одной диагонали)
//--------------------------------------------------------------
bool Checkers::valid(int i1, int k1, int i2, int k2)
{
    return ((i1-i2) == (k1-k2)) || ((i1-i2) == (k2-k1));
}

//-------------------------------------------------------------------------------------
//-- Закрытые методы - логика функционирования объекта
//-------------------------------------------------------------------------------------

// Процедура аналиа позиции после очередного хода
// Проверяется налисие допустимых ходов
// По результатам устанавливаются признаки game_ended и must_bit
//--------------------------------------------------------------
void Checkers::testCurrentPosition()
{
    // Устанавливаем начальное состояние признаков
    game_ended = true;
    must_bit = false;

    // Переьираем все клетки
    for (int i=0; i<8; i++)     // Двойной цикл по координатам
    {
        for (int k=0; k<8; k++)
        {
            // Обрабатываем только клетки, занятые шашками цвета хода
            // Для этого на тип клетки накладываем нужную маску
            // и результат сравниваем с признаком очередности хода
            if ((getType(i, k) & checker_mask) == move_order)
            {
                // Проверяем, может ли эта шашка бить
                if (canBit(i, k))   // Если может, то перебор окончен
                {
                    game_ended = false; // Устанавливаем оба признака
                    must_bit = true;
                    return;             // и выходим
                }
                // Иначе проверяем, может ли эта шашка сделать тихий ход
                // (только если ходов до сих пор не найдено)
                else if (game_ended && canMove(i, k))
                {
                    game_ended = false; // Если может, то не конец игры
                }
            }
        }
    }
}

// Проверка возможности тихого хода из данной клетки
//--------------------------------------------------------------
bool Checkers::canMove(int i, int k)
{
    // Перебираем в цикле все четыре направления
    for (int d = 0; d < 4; d++)
    {
        // Проверяем каждое направление отдельно
        if (canMoveInDirection(i, k, d))
        {
            // Если хоть одна возможность найдена, успех
            return true;
        }
    }
    // Если ни одной возможности не найдено, неудача
    return false;
}

// Проверка возможности тихого хода из данной клетки в даном направлении
//--------------------------------------------------------------
bool Checkers::canMoveInDirection(int i, int k, int d)
{
    // Для простых шашек нужно проверить направление
    if (!(getType(i, k) & dame))
    {
        // Белая шашка не может ходить вниз
        if (white_checker & move_order)
        {
            if (d & 2) return false;
        }
        // Черная шашка не может ходить вверх
        else
        {
            if (!(d & 2)) return false;
        }
    }
    // В остальных случаях возможность сделать тихий ход
    // это в точности пустота следующей клетки
    return (getType(nextI(i, d), nextK(k, d)) & empty_mask) == 0;
}

// Проверка возможности боя из данной клетки
//--------------------------------------------------------------
bool Checkers::canBit(int i, int k)
{
    // Перебираем в цикле все четыре направления
    for (int d = 0; d < 4; d++)
    {
        // Проверяем каждое направление отдельно
        if (canBitInDirection(i, k, d))
        {
            // Если хоть одна возможность найдена, успех
            return true;
        }
    }
    // Если ни одной возможности не найдено, неудача
    return false;
}

// Проверка возможности боя из данной клетки в даном направлении
//--------------------------------------------------------------
bool Checkers::canBitInDirection(int i, int k, int d)
{
    // Для дамок следует пропустить все пустые клетки
    // в данном направлении
    if (getType(i, k) & dame)
    {
        // Цикл пока следующая клетка пустая
        while ((getType(nextI(i, d), nextK(k, d)) & empty_mask) == 0)
        {
            i = nextI(i, d);
            k = nextK(k, d);
        }
    }

    // Координаты шашки, которая будет бита
    // для простой шашки это следующая клетка
    // для дамки - первая непустая в данном направлении
    i = nextI(i, d);
    k = nextK(k, d);

    // Проверяем, что эта клетка занята шакой противоположного цвета
    if ((getType(i, k) & checker_mask) != (move_order ^ white_checker)) return false;
    // Проверяем пустоту следующей за ней клетки
    return (getType(nextI(i, d), nextK(k, d)) & empty_mask) == 0;
}

// Проверка возможности и выполнение тихого хода для пары клеток
//--------------------------------------------------------------
bool Checkers::move(int i1, int k1, int i2, int k2)
{
    // Если бой вернул код ошибки больше 1,
    // то дальше проверять уже не нужно
    if (error_code > 1) return false;

    // На этом этапе прекращение работы
    // означает код ошибки 2
    error_code = 2;

    // Если установлен флаг необходимости бить шашку,
    // тихий ход выполнять нельзя, код ошибки 2
    if (must_bit) return false;

    // На этом этапе прекращение работы
    // означает код ошибки 1
    error_code = 1;

    // Проверяем нахождение клеток на одной диагонали
    if (!valid(i1, k1, i2, k2)) return false;

    // Вычисляем числовое значение направления хода
    int d = direction(i1, k1, i2, k2);

    // Если ходит дамка
    if (getType(i1, k1) & dame)
    {
        int i = i1;     // Начинаем с первой клетки
        int k = k1;
        // в цикле, пока не дойдем до второй клетки
        while ((i != i2) && (k != k2))
        {
            i = nextI(i, d);    // Продвигаемся в нужном направлении
            k = nextK(k, d);

            // Если вдруг встретилась занятая клетка -
            // помеха ходу, прекращаем анализ, неуспех
            if (getType(i,k) & empty_mask) return false;
        }
    }
    else
    // Если ходит простая шашка
    {
        // Нужно проверить направление
        if (white_checker & move_order)
        {
            // Белая шашка не может ходить вниз
            if (d & 2) return false;
        }
        else
        {
            // Черная шашка не может ходить вверх
            if (!(d & 2)) return false;
        }

        // Проверяем, что вторая клетка - следующая за первой
        if (i2 != nextI(i1, d)) return false;
        if (k2 != nextK(k1, d)) return false;
    }

    // Успешнеое завершение хода

    // На этом этапе прекращение работы
    // означает код ошибки 0 - отсутствие ошибок
    error_code = 0;

    // Обмениваем содержимое двух клеток
    int temp = position[i1][k1];
    position[i1][k1] = position[i2][k2];
    position[i2][k2] = temp;

    // Проверяем необходимость превращения в дамки
    convertIntoDame(i2,k2);
    return true;
}

// Проверка возможности и выполнение боя для пары клеток
//--------------------------------------------------------------
bool Checkers::bit(int i1, int k1, int i2, int k2)
{
    // На этом этапе прекращение работы
    // означает код ошибки 1
    error_code = 1;

    // Проверяем нахождение клеток на одной диагонали
    if (!valid(i1, k1, i2, k2)) return false;

    // Вычисляем числовое значение направления хода
    int d = direction(i1, k1, i2, k2);

    // Начинаем с первой клетки
    int i = i1;
    int k = k1;

    // Для дамок следует пропустить все пустые клетки
    // в данном направлении
    if (getType(i1, k1) & dame)
    {
        // Цикл пока следующая клетка пустая
        while ((getType(nextI(i, d), nextK(k, d)) & empty_mask) == 0)
        {
            i = nextI(i, d);    // Продвигаемся в нужном направлении
            k = nextK(k, d);
        }
    }

    // Координаты шашки, которая будет бита
    // для простой шашки это следующая клетка
    // для дамки - первая непустая в данном направлении
    i = nextI(i, d);
    k = nextK(k, d);

    // Проверяем, что эта клетка занята шакой противоположного цвета
    if ((getType(i, k) & checker_mask) != (move_order ^ white_checker)) return false;

    // Фиксируем координаты побитой клетки
    int i_bit = i;
    int k_bit = k;

    // Если ходит дамка
    if (getType(i1, k1) & dame)
    {
        // в цикле, пока не дойдем до второй клетки
        while ((i != i2) && (k != k2))
        {
            i = nextI(i, d);    // Продвигаемся в нужном направлении
            k = nextK(k, d);

            // Если вдруг встретилась занятая клетка -
            // помеха ходу, прекращаем анализ, неуспех
            if (getType(i,k) & empty_mask) return false;
        }

        // Последующий участок проверяет ситуацию,
        // когда дамка остановилась после боя на такой клетке,
        // с которой она не может продолжать бой,
        // а на той же диагонали есть клетки,
        // с которых бой продолжать можно.
        // Это ошибка, дамка не может остановиться здесь.

        // Временно пометим побитую шашку,
        // это нужно для правильной проверки
        position[i_bit][k_bit] |= bited_checker;

        // Если с конечной клетки бить дальше нельзя
        if (! canBit(i2,k2))
        {
            // Начинаем с клетки, следующей за побитой
            i = nextI(i_bit, d);
            k = nextK(k_bit, d);

            // Цикл пока клетка пустая
            while ((getType(i, k) & empty_mask) == 0)
            {
                // Если найдена клетка, с которой бить можно
                if (canBit(i,k))
                {
                    // Устанавливаем код ошибки 3 -
                    // дамка должна бить дальше с другой клетки
                    error_code = 3;

                    // Снимаем ранее поставленную пометку -
                    // этот этап хода отменен
                    position[i_bit][k_bit] &= ~bited_checker;

                    // Возврат
                    return false;
                }
                i = nextI(i, d);    // Продвигаемся в нужном направлении
                k = nextK(k, d);
            }
        }
    }
    else
    // Если ходит простая шашка
    {
        // Проверяем, что вторая клетка - следующая за первой
        if (i2 != nextI(i_bit, d)) return false;
        if (k2 != nextK(k_bit, d)) return false;
    }

    // Успешнеое завершение хода

    // На этом этапе прекращение работы
    // означает код ошибки 0 - отсутствие ошибок
    error_code = 0;

    // Помечаем побитую шашку соответствующим флажком
    position[i_bit][k_bit] |= bited_checker;

    // Обмениваем содержимое двух клеток
    int temp = position[i1][k1];
    position[i1][k1] = position[i2][k2];
    position[i2][k2] = temp;

    // Проверяем необходимость превращения в дамки
    convertIntoDame(i2,k2);
    return true;
}

// Проверка необходимости и выполнение превращения в дамки
//--------------------------------------------------------------
void Checkers::convertIntoDame(int i, int k)
{
    // Если черная шашка достигла нижней горизонтали
    if (((getType(i, k) & checker_mask) == occupied_field) && (k == 7))
    {
        position[i][k] |= dame;     // Устанавливаем признак дамки
    }
    // Если белая шашка достигла верхней горизонтали
    if (((getType(i, k) & checker_mask) == (occupied_field | white_checker)) && (k == 0))
    {
        position[i][k] |= dame;     // Устанавливаем признак дамки
    }
}

// Удаление с доски шашек, побитых в течение хода
//--------------------------------------------------------------
void Checkers::deleteBited()
{
    for (int i=0; i<8; i++)     // Двойной цикл по координатам
    {
        for (int k=0; k<8; k++)
        {
            // Если шашка помечена как битая, заменякм содержимое клетки
            if (getType(i, k) & bited_checker) position[i][k] = black_empty_field;
        }
    }
}

